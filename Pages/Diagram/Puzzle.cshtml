@page
@model EJ2CoreSampleBrowser.Pages.Diagram.PuzzleModel
@using Syncfusion.EJ2;

@section ControlsSection {
    <div class="control-section">
        <div class="content-wrapper" style="width: 100%">
            <ejs-diagram id="diagram" class="puzzle-diagram" height="800px" click="click" load="onLoad" created="onCreated" constraints="@Model.Constraints">
                <e-diagram-scrollsettings scrollLimit="Diagram" canAutoScroll="false"></e-diagram-scrollsettings>
                <e-diagram-snapsettings constraints="None"></e-diagram-snapsettings>
                <e-diagram-selecteditems constraints="None"></e-diagram-selecteditems>
            </ejs-diagram>
            <!-- Win Dialog (initially hidden) -->
            <div id="winDialog" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 1000;">
                <div style="background: #2c2c2c; padding: 40px; border-radius: 20px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); font-family: Arial, sans-serif; position: relative; display: inline-block;">
                    <div id="winClose" style="position: absolute; top: 15px; right: 20px; font-size: 24px; cursor: pointer; color: #ccc;" title="Close" tabindex="0" aria-label="Close dialog">✕</div>
                    <div style="font-size: 80px; margin-bottom: 20px;">🎉</div>
                    <h1 style="margin-bottom: 20px; font-size: 36px; font-weight: bold;">Congratulations!</h1>
                    <p style="font-size: 18px; margin-bottom: 30px;">you did it in <span id="finalMoves">0</span></p>
                </div>
            </div>
        </div>
    </div>

    <style>
        .timer-container {
            width: 100%;
            max-width: 1000px;
            margin: 20px auto;
        }

        .timer {
            display: flex;
            align-items: center;
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            padding: 10px 10px;
            border-radius: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), 0 0 15px rgba(173, 216, 230, 0.2);
            border: 1px solid rgba(33, 150, 243, 0.3);
            transition: all 0.2s ease-in-out;
            gap: 10px;
            justify-content: center;
        }

        .moves-counter {
            display: flex;
            align-items: center;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), 0 0 15px rgba(144, 238, 144, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.3);
            transition: all 0.2s ease-in-out;
            gap: 10px;
            justify-content: center;
        }

            .moves-counter .label, .timer .label {
                font-weight: 700;
                text-transform: uppercase;
                font-size: 15px;
                color: white;
                padding: 0px !important;
            }

            .moves-counter .count, .timer .time-display {
                font-size: 18px;
                font-weight: 700;
                letter-spacing: 0.5px;
                color: white;
            }

        .pause-btn {
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            width: 150px;
            gap: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease;
        }

            .pause-btn:hover {
                background-color: #1976D2;
            }

            .pause-btn .icon {
                font-size: 16px;
            }

        .new-game-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease;
            white-space: nowrap;
        }

            .new-game-btn:hover {
                background-color: #45a049;
            }

            .new-game-btn .icon {
                font-size: 16px;
            }

        .number-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-top: 2px;
            margin-left: 2px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #333333 0%, #000000 100%);
            border: 3px solid #666;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5), inset 0 2px 4px rgba(255, 255, 255, 0.2), inset 0 -2px 4px rgba(0, 0, 0, 0.8);
            font-family: 'Arial Black', Arial, sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8), -1px -1px 1px rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

            .number-badge::before {
                content: '';
                position: absolute;
                top: -50%;
                left: -50%;
                width: 200%;
                height: 200%;
                background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
                transform: rotate(45deg);
                pointer-events: none;
            }
    </style>
    <style>
        .game-button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 140px;
            position: relative;
            overflow: hidden;
        }

            .game-button::before {
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
                transition: left 0.5s;
            }

            .game-button:hover::before {
                left: 100%;
            }

        .new-game-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: 2px solid #45a049;
        }

            .new-game-btn:hover {
                background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(76, 175, 80, 0.4);
            }

            .new-game-btn:active {
                transform: translateY(0);
                box-shadow: 0 2px 4px rgba(76, 175, 80, 0.4);
            }

        .pause-btn {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border: 2px solid #1976D2;
        }

            .pause-btn:hover {
                background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(33, 150, 243, 0.4);
            }

            .pause-btn:active {
                transform: translateY(0);
                box-shadow: 0 2px 4px rgba(33, 150, 243, 0.4);
            }

        .game-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

            .game-button:disabled:hover {
                transform: none;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }

        .puzzle-tile {
            position: relative;
            width: 90px;
            height: 90px;
            background: linear-gradient(135deg, #d4a574 0%, #c49660 50%, #b8864d 100%);
            border: 3px solid #8b6914;
            border-radius: 8px;
            box-shadow: inset 2px 2px 4px rgba(255, 255, 255, 0.3), inset -2px -2px 4px rgba(0, 0, 0, 0.2), 2px 2px 8px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
        }

            .puzzle-tile:hover {
                transform: translateY(-2px);
                box-shadow: inset 2px 2px 4px rgba(255, 255, 255, 0.4), inset -2px -2px 4px rgba(0, 0, 0, 0.3), 2px 4px 12px rgba(0, 0, 0, 0.4);
            }

            .puzzle-tile.selected {
                border-color: #ffd700;
                box-shadow: 0 0 0 3px #ffd700, inset 2px 2px 4px rgba(255, 255, 255, 0.4), inset -2px -2px 4px rgba(0, 0, 0, 0.3), 2px 4px 12px rgba(255, 215, 0, 0.5);
            }

        .tile-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: repeating-linear-gradient( 90deg, transparent, transparent 1px, rgba(139, 105, 20, 0.1) 1px, rgba(139, 105, 20, 0.1) 2px ), repeating-linear-gradient( 0deg, transparent, transparent 1px, rgba(139, 105, 20, 0.1) 1px, rgba(139, 105, 20, 0.1) 2px );
        }

        .tile-number {
            font-family: 'Arial Black', Arial, sans-serif;
            font-size: 32px;
            font-weight: bold;
            color: #4a3728;
            text-shadow: 1px 1px 0px rgba(255, 255, 255, 0.3), -1px -1px 0px rgba(0, 0, 0, 0.3);
            user-select: none;
        }

        .tile-highlight {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, transparent 50%);
            pointer-events: none;
            border-radius: 5px;
        }
        /* Wood grain texture overlay */
        .puzzle-tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: radial-gradient(circle at 20% 50%, rgba(139, 105, 20, 0.1) 0%, transparent 50%), radial-gradient(circle at 80% 20%, rgba(139, 105, 20, 0.1) 0%, transparent 50%), radial-gradient(circle at 40% 80%, rgba(139, 105, 20, 0.1) 0%, transparent 50%);
            pointer-events: none;
            border-radius: 5px;
        }
        /* Disabled state */
        .puzzle-tile.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

            .puzzle-tile.disabled:hover {
                transform: none;
                box-shadow: inset 2px 2px 4px rgba(255, 255, 255, 0.3), inset -2px -2px 4px rgba(0, 0, 0, 0.2), 2px 2px 8px rgba(0, 0, 0, 0.3);
            }

        .diagram-panel {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #20B2AA 0%, #7B68EE 100%);
            border-radius: 20px;
            margin-right: 20px;
            box-shadow: 0 15px 35px rgba(32, 178, 170, 0.4);
            position: relative;
            overflow: hidden;
        }

            .diagram-panel::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-image: radial-gradient(circle, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
                background-size: 30px 30px;
                pointer-events: none;
            }

        .clue-btn {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
            border: 2px solid #F57C00;
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            white-space: nowrap;
        }

            .clue-btn:hover {
                background: linear-gradient(135deg, #F57C00 0%, #E65100 100%);
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(255, 152, 0, 0.4);
            }

            .clue-btn:active {
                transform: translateY(0);
                box-shadow: 0 2px 4px rgba(255, 152, 0, 0.4);
            }

            .clue-btn .icon {
                font-size: 16px;
            }
    </style>
    <script>
        // --- Puzzle Logic (adapted from TypeScript) ---
        var diagram;
        var gameBoard = new Array(16);
        var emptyIndex = 0;
        var moveCount = 0;
        var gameTimer = null;
        var elapsedSeconds = 0;
        var timeDisplay = "00:00";
        var isPaused = false;
        var gameStarted = false;
        var showWinDialog = false;
        var showClue = false;
        var isPuzzleSolved = false;
        var diagramCreated = false;
        var nodes = [];

        // Image collections
        var imageCollections = [];
        var currentImageMap;
        var currentThemeIndex = 0;
        var imageRandom = Math.random;

        // Constants
        const TILE_WIDTH = 130;
        const TILE_HEIGHT = 130;
        const TILE_GAP = 5;
        const GRID_SIZE = 4;

        function initializeImageCollections() {
            // bridge theme
            var bridgeTheme = {};
            // Nature theme
            var natureTheme = {};
            // Man theme
            var manTheme = {};

            for (var i = 1; i <= 16; i++) {
                var row = Math.ceil(i / 4);
                var col = ((i - 1) % 4) + 1;
                bridgeTheme[i] = `../images/Diagram/puzzle/bridge${col}x${row}.png`;
                natureTheme[i] = `../images/Diagram/puzzle/image${col}x${row}.png`;
                manTheme[i] = `../images/Diagram/puzzle/man${col}x${row}.png`;
            }

            imageCollections = [bridgeTheme, natureTheme, manTheme];
            currentImageMap = imageCollections[0];
            currentThemeIndex = 0;
        }

        function createDiagram() {
            diagram.clear();
            createNodes();
            diagram.nodes = nodes;
            diagram.dataBind();
            diagram.fitToPage();
        }

        function onCreated() {
            diagramCreated = true;
            diagram = document.getElementById("diagram").ej2_instances[0];
            initializeImageCollections();
            initializeGame();
            setupTimer();
            createDiagram();
            setupEventListeners();
            diagram.tool = ej.diagrams.DiagramTools.SingleSelect | ej.diagrams.DiagramTools.ZoomPan;
            diagram.fitToPage();
        }
        function onLoad() {
            if (diagramCreated) {
                setTimeout(() => diagram.fitToPage(), 10);
            }
        }
        function createNodes() {
            nodes = [];
            // Background Node
            var backgroundNode = {
                id: "backgroundNode",
                offsetX: 788,
                offsetY: 392,
                height: 755,
                width: 639,
                style: {
                    fill: "#B0C4DE",
                    opacity: 0.5
                },
                constraints: ej.diagrams.NodeConstraints.None,
                shape: {
                    type: 'Basic',
                    shape: 'Rectangle',
                    cornerRadius: 5
                }
            };
            nodes.push(backgroundNode);

            // Moves counter node
            var moveNode = {
                id: "moves",
                offsetX: 580,
                offsetY: 80,
                width: 160, height: 100,
                constraints: ej.diagrams.NodeConstraints.None,
                shape: {
                    type: 'HTML',
                    content: getMovesTemplate()
                }
            };
            nodes.push(moveNode);

            // Time node
            var timeNode = {
                id: "time",
                offsetX: 1004,
                offsetY: 80,
                width: 160, height: 100,
                constraints: ej.diagrams.NodeConstraints.None,
                shape: {
                    type: 'HTML',
                    content: getTimeTemplate()
                }
            };
            nodes.push(timeNode);

            // New game button
            var newGameNode = {
                id: "newgame",
                offsetX: 600,
                offsetY: 725,
                width: 150, height: 50,
                constraints: ej.diagrams.NodeConstraints.PointerEvents,
                shape: {
                    type: 'HTML',
                    content: getNewGameTemplate()
                }
            };
            nodes.push(newGameNode);

            // Pause button
            var pauseNode = {
                id: "pause",
                offsetX: 990,
                offsetY: 725,
                width: 150, height: 50,
                constraints: ej.diagrams.NodeConstraints.PointerEvents,
                shape: {
                    type: 'HTML',
                    content: getPauseTemplate()
                }
            };
            nodes.push(pauseNode);

            // Clue button
            var clueNode = {
                id: "clue",
                offsetX: 790,
                offsetY: 725,
                width: 150, height: 50,
                constraints: ej.diagrams.NodeConstraints.PointerEvents,
                shape: {
                    type: 'HTML',
                    content: getClueTemplate()
                }
            };
            nodes.push(clueNode);

            // Create puzzle tiles
            for (var i = 0; i < gameBoard.length; i++) {
                if (gameBoard[i] !== 0) {
                    var pieceNumber = gameBoard[i];
                    var isInCorrectPosition = (i + 1) === pieceNumber;

                    var node = {
                        id: `tile${pieceNumber}`,
                        width: TILE_WIDTH,
                        height: TILE_HEIGHT,
                        offsetX: getTileX(i),
                        offsetY: getTileY(i),
                        annotations: [{
                            id: `annotation${pieceNumber}`,
                            width: 25,
                            height: 25,
                            template: getAnnotationTemplate(pieceNumber),
                            visibility: false,
                            offset: { x: 0.7, y: 0.1 },
                            horizontalAlignment: 'Center',
                            verticalAlignment: 'Center'
                        }],
                        style: {
                            strokeColor: "white"
                        },
                        shape: {
                            type: 'Image',
                            source: getImageSourceForTile(pieceNumber)
                        }
                    };

                    if (canMoveTile(i)) {
                        node.constraints = ej.diagrams.NodeConstraints.PointerEvents;
                    } else {
                        node.constraints = ej.diagrams.NodeConstraints.None;
                    }

                    nodes.push(node);
                }
            }
        }

        function getMovesTemplate() {
            return `<div class="moves-counter">
                                    <div class="label">MOVES: </div>
                                    <div class="count">${moveCount}</div>
                                </div>`;
        }

        function getTimeTemplate() {
            return `<div class="timer">
                                    <div class="label">TIME: </div>
                                    <div class="time-display">${timeDisplay}</div>
                                </div>`;
        }

        function getNewGameTemplate() {
            return `<button class="new-game-btn" id="newGameBtn">
                                    <span class="icon">🎮</span>
                                    NEW GAME
                                </button>`;
        }

        function getClueTemplate() {
            return `<button class="clue-btn" id="clueBtn">
                                    <span class="icon">💡</span>
                                    <span class="text">${showClue ? "HIDE CLUE" : "SHOW CLUE"}</span>
                                </button>`;
        }

        function getPauseTemplate() {
            return `<button class="pause-btn" id="pauseBtn">
                                    <span class="icon">${isPaused ? "▶️" : "⏸️"}</span>
                                    <span class="text">${isPaused ? "RESUME" : "PAUSE"}</span>
                                </button>`;
        }

        function getAnnotationTemplate(pieceNumber) {
            return `<div class="number-badge">${pieceNumber}</div>`;
        }

        function initializeGame() {
            // Initialize solved state
            for (var i = 0; i < 15; i++) {
                gameBoard[i] = i + 1;
            }
            gameBoard[15] = 0;

            emptyIndex = 15;
            shuffleBoard();
            moveCount = 0;
            isPuzzleSolved = false;
            elapsedSeconds = 0;
            updateTimeDisplay();
            gameStarted = false;
            createNodes();
        }

        function setupTimer() {
            gameTimer = setInterval(() => {
                onTimerElapsed();
            }, 1000);
        }

        function onTimerElapsed() {
            if (!isPaused && gameStarted && !isPuzzleSolved) {
                elapsedSeconds++;
                updateTimeDisplay();
                updateUI();
            }
        }

        function updateTimeDisplay() {
            var minutes = Math.floor(elapsedSeconds / 60);
            var seconds = elapsedSeconds % 60;
            timeDisplay = padZero(minutes) + ':' + padZero(seconds);
        }
        function padZero(num) {
            return (num < 10 ? '0' : '') + num;
        }

        function getTileX(index) {
            var col = index % GRID_SIZE;
            var startX = 600;
            return startX + (col * TILE_WIDTH);
        }

        function getTileY(index) {
            var row = Math.floor(index / GRID_SIZE);
            var startY = 200;
            return startY + (row * TILE_HEIGHT);
        }

        function canMoveTile(tileIndex) {
            var tileRow = Math.floor(tileIndex / 4);
            var tileCol = tileIndex % 4;
            var emptyRow = Math.floor(emptyIndex / 4);
            var emptyCol = emptyIndex % 4;

            var isVerticallyAdjacent = (Math.abs(tileRow - emptyRow) === 1 && tileCol === emptyCol);
            var isHorizontallyAdjacent = (Math.abs(tileCol - emptyCol) === 1 && tileRow === emptyRow);

            return isVerticallyAdjacent || isHorizontallyAdjacent;
        }

        function addFinalPiece() {
            var finalPiece = {
                id: "tile16final",
                width: 130,
                height: 130,
                offsetX: getTileX(15),
                offsetY: getTileY(15),
                style: {
                    fill: "transparent",
                    strokeColor: "#FFD700",
                    strokeWidth: 4
                },
                shape: {
                    type: 'Image',
                    source: getImageSourceForTile(16)
                },
                annotations: [{
                    id: "annotation16",
                    width: 25,
                    height: 25,
                    template: getAnnotationTemplate(16),
                    offset: { x: 0.9, y: 0.1 },
                    horizontalAlignment: 'Center',
                    verticalAlignment: 'Center'
                }],
                constraints: ej.diagrams.NodeConstraints.None
            };

            diagram.add(finalPiece);
        }

        function checkPuzzleSolved() {
            var solved = true;
            for (var i = 0; i < 15; i++) {
                if (gameBoard[i] !== i + 1) {
                    solved = false;
                    break;
                }
            }
            if (solved && gameBoard[15] !== 0) {
                solved = false;
            }
            if (solved && emptyIndex === 15) {
                isPuzzleSolved = true;
                if (gameTimer) {
                    clearInterval(gameTimer);
                }

                addFinalPiece();
                showCompletionMessage();
            }
        }

        function moveTileToEmptySpace(tileNumber) {
            var tileIndex = gameBoard.indexOf(tileNumber);
            if (!canMoveTile(tileIndex)) return;

            if (!gameStarted) {
                gameStarted = true;
                elapsedSeconds = 0;
                updateTimeDisplay();
            }

            var oldEmptyIndex = emptyIndex;
            gameBoard[emptyIndex] = tileNumber;
            gameBoard[tileIndex] = 0;
            emptyIndex = tileIndex;
            moveCount++;

            var node = diagram.getObject(`tile${tileNumber}`);
            if (node) {
                node.offsetX = getTileX(oldEmptyIndex);
                node.offsetY = getTileY(oldEmptyIndex);
                diagram.dataBind();
            }

            enableAdjacentNodes();
            checkPuzzleSolved();
            updateUI();
        }

        function newGame() {
            if (gameTimer) {
                clearInterval(gameTimer);
            }
            selectRandomImageCollection();
            moveCount = 0;
            elapsedSeconds = 0;
            gameStarted = false;
            isPaused = false;
            isPuzzleSolved = false;
            showWinDialog = false;
            showClue = false;

            // Reset board
            for (var i = 0; i < 15; i++) {
                gameBoard[i] = i + 1;
            }
            gameBoard[15] = 0;
            emptyIndex = 15;

            updateTimeDisplay();
            shuffleBoard();
            clearDiagramNodes();
            createNodes();
            diagram.nodes = nodes;
            enableAdjacentNodes();
            setupTimer();
            updateUI();
        }

        function shuffleBoard() {
            for (var i = 0; i < 1000; i++) {
                var validMoves = getValidMoves();
                if (validMoves.length > 0) {
                    var randomMove = validMoves[Math.floor(imageRandom() * validMoves.length)];
                    gameBoard[emptyIndex] = gameBoard[randomMove];
                    gameBoard[randomMove] = 0;
                    emptyIndex = randomMove;
                }
            }
        }

        function getValidMoves() {
            var validMoves = [];
            var emptyRow = Math.floor(emptyIndex / 4);
            var emptyCol = emptyIndex % 4;
            var directions = [-4, 4, -1, 1];

            for (var dir of directions) {
                var newIndex = emptyIndex + dir;
                if (newIndex >= 0 && newIndex < 16) {
                    var newRow = Math.floor(newIndex / 4);
                    var newCol = newIndex % 4;
                    if ((dir === -1 || dir === 1) && Math.abs(newRow - emptyRow) === 0 && Math.abs(newCol - emptyCol) === 1) {
                        validMoves.push(newIndex);
                    } else if ((dir === -4 || dir === 4) && Math.abs(newRow - emptyRow) === 1 && Math.abs(newCol - emptyCol) === 0) {
                        validMoves.push(newIndex);
                    }
                }
            }

            return validMoves;
        }

        function togglePause() {
            isPaused = !isPaused;

            if (isPaused) {
                if (gameTimer) {
                    clearInterval(gameTimer);
                }
                disableAllNodes();
            } else {
                setupTimer();
                enableAdjacentNodes();
            }

            updateUI();
        }

        function disableAllNodes() {
            for (var node of diagram.nodes) {
                if (node.id.startsWith("tile")) {
                    node.constraints = ej.diagrams.NodeConstraints.None;
                }
            }
            diagram.dataBind();
        }

        function clearDiagramNodes() {
            if (diagram) {
                var existingNodes = [...diagram.nodes];
                for (var node of existingNodes) {
                    diagram.remove(node);
                }
            }
            nodes = [];
        }

        function enableAdjacentNodes() {
            for (const node of diagram.nodes) {
                if (node.id.startsWith("tile")) {
                    const tileNumber = parseInt(node.id.substring(4));
                    const tileIndex = gameBoard.indexOf(tileNumber);

                    if (canMoveTile(tileIndex)) {
                        node.constraints = ej.diagrams.NodeConstraints.PointerEvents;
                    } else {
                        node.constraints = ej.diagrams.NodeConstraints.None;
                    }
                }
            }
            diagram.dataBind();
        }

        function toggleClue() {
            showClue = !showClue;
            for (var node of diagram.nodes) {
                if (node.annotations && node.annotations.length > 0) {
                    node.annotations[0].visibility = showClue;
                }
            }
            diagram.dataBind();
            updateUI();
        }

        function selectRandomImageCollection() {
            if (imageCollections.length > 1) {
                var newIndex;
                do {
                    newIndex = Math.floor(imageRandom() * imageCollections.length);
                } while (newIndex === currentThemeIndex);

                currentThemeIndex = newIndex;
                currentImageMap = imageCollections[currentThemeIndex];
            }
        }

        function getImageSourceForTile(tileNumber) {
            return currentImageMap && currentImageMap[tileNumber] ? currentImageMap[tileNumber] : "";
        }

        function showCompletionMessage() {
            showWinDialog = true;
            var winDialog = document.getElementById('winDialog');
            var finalMoves = document.getElementById('finalMoves');
            if (winDialog) {
                winDialog.style.display = 'flex';
            }
            if (finalMoves) {
                finalMoves.textContent = moveCount.toString()+" steps in " + timeDisplay;
            }
        }

        function closeWinDialog() {
            showWinDialog = false;
            var winDialog = document.getElementById('winDialog');
            if (winDialog) {
                winDialog.style.display = 'none';
            }
            newGame();
        }

        function updateUI() {
            // Update moves counter
            var moveNode = diagram.getObject('moves');
            if (moveNode && moveNode.shape && (moveNode.shape).content) {
                (moveNode.shape).content = getMovesTemplate();
            }

            // Update timer
            var timeNode = diagram.getObject('time');
            if (timeNode && timeNode.shape && (timeNode.shape).content) {
                (timeNode.shape).content = getTimeTemplate();
            }

            // Update pause button
            var pauseNode = diagram.getObject('pause');
            if (pauseNode && pauseNode.shape && (pauseNode.shape).content) {
                (pauseNode.shape).content = getPauseTemplate();
            }

            // Update clue button
            var clueNode = diagram.getObject('clue');
            if (clueNode && clueNode.shape && (clueNode.shape).content) {
                (clueNode.shape).content = getClueTemplate();
            }

            diagram.dataBind();
        }

        function setupEventListeners() {
            document.getElementById('winClose').addEventListener('click', () => closeWinDialog());
        }

        function click(args) {
            if (args.actualObject instanceof ej.diagrams.Node) {
                var node = args.actualObject;
                if (node.id === 'newgame') {
                    newGame();
                }
                else if (node.id === 'pause') {
                    togglePause();
                }
                else if (node.id === 'clue') {
                    toggleClue();
                }
                else if (node.id.startsWith("tile")) {
                    if (isPaused || isPuzzleSolved) return;

                    if (!gameStarted) {
                        gameStarted = true;
                        elapsedSeconds = 0;
                        updateTimeDisplay();
                    }

                    var nodeId = node.id;
                    if (nodeId.startsWith("tile")) {
                        var tileNumber = parseInt(nodeId.substring(4));
                        moveTileToEmptySpace(tileNumber);
                    }
                }
            }
        }
    </script>

}
@section ActionDescription{
    <p>
        This sample showcases an interactive sliding image puzzle game built using the Syncfusion<sup>®</sup> ASP.NET Core Diagram component, transforming images into a 4x4 grid of draggable tiles, with features like move and time tracking.
    </p>
}
@section Meta{
    <meta name="description" content="Play a sliding image puzzle with Syncfusion ASP.NET Core Diagram. Drag tiles, track moves and time, and enjoy multiple themes with pause and clue options." />
}

@section Description{
    <p>
        This interactive 4x4 sliding image puzzle challenges users to reconstruct an image by moving tiles adjacent to an empty space. The game dynamically tracks moves and time, offering multiple image themes, pause/resume functionality, and a "Clue" option. A congratulatory message with statistics appears upon puzzle completion.
    </p>
}
@section Title{
    <title>ASP.NET Core Interactive Puzzle Diagram Example - Syncfusion Demos </title>
}
@section Header{
    <h1 class='sb-sample-text'>Example of Interactive Sliding Image Puzzle Game in ASP.NET Core Diagram Component</h1>
}