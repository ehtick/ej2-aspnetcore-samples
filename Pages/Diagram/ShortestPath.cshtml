@page
@model EJ2CoreSampleBrowser.Pages.Diagram.ShortestPathModel
@using Syncfusion.EJ2;
@using Syncfusion.EJ2.DropDowns;
@{
    var getNodeDefaults = "getNodeDefaults";
    var getConnectorDefaults = "getConnectorDefaults";
} 
@section ControlsSection {
    <div class="control-section">
    <div class="content-wrapper" style="width: 100%">
            <div style="display: flex; justify-content: center; margin: 20px; align-items: center;">
                <ejs-switch id="default" checked="true" change="onGraphTypeChanged"></ejs-switch>
                <label style="margin-left: 15px; font-size: 18px; font-weight: 500;">Directed Graph</label>
            </div>
            <ejs-diagram id="container" width="100%" height="700px" nodes="@Model.Nodes" connectors="@Model.Connectors" created="Create"
                         click="onNodeClicked" mouseEnter="onMouseEnter" mouseLeave="onMouseLeave">
                <e-diagram-scrollsettings scrollLimit="Diagram" canAutoScroll="false"></e-diagram-scrollsettings>
                <e-diagram-snapsettings constraints="None"></e-diagram-snapsettings>
            </ejs-diagram>
    </div>
</div>


 
    <script>
            var dashIntervals = new Map();
        // Constants for colors and styles
        var nodeHighlightFill = '#6495ED';
        var nodeHighlightStroke = '#4472C4';
        var nodeDefaultFill = 'white';
        var nodeDefaultStroke = '#333333';
        var nodeErrorFill = '#FF6565';
        var nodeErrorStroke = '#EE3636';
        var connectorHighlightStroke = '#4472C4';
        var connectorDefaultStroke = '#333333';
        var diagram;
        var graphSwitch;
        var graph = new Map();
        var selectedNode = 'A';
        var highlightedNodes = [];
        var highlightedConnectors = [];
        var isDirectedGraph = true;
        var previousNode = null;
        var diagramCreated = false;
   
        
            function buildGraph() {
                 var diagram = document.getElementById("container").ej2_instances[0];
            var nodeIds = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'X', 'Y'];
            // Initialize graph
            nodeIds.forEach(function (nodeId) {
                graph.set(nodeId, []);
            });
            var edges = [
                { from: 'A', to: 'B' }, { from: 'A', to: 'D' }, { from: 'A', to: 'X' },
                { from: 'B', to: 'D' }, { from: 'B', to: 'H' }, { from: 'B', to: 'X' },
                { from: 'B', to: 'C' }, { from: 'B', to: 'K' }, { from: 'C', to: 'L' },
                { from: 'C', to: 'X' }, { from: 'D', to: 'F' }, { from: 'E', to: 'X' },
                { from: 'F', to: 'H' }, { from: 'G', to: 'H' }, { from: 'G', to: 'Y' },
                { from: 'G', to: 'K' }, { from: 'H', to: 'I' }, { from: 'I', to: 'J' },
                { from: 'I', to: 'K' }, { from: 'I', to: 'L' }, { from: 'J', to: 'L' },
                { from: 'K', to: 'Y' }
            ];
            // Build bidirectional adjacency list
            edges.forEach(function (edge) {
                var fromNeighbors = graph.get(edge.from);
                var toNeighbors = graph.get(edge.to);
                if (fromNeighbors) fromNeighbors.push(edge.to);
                if (toNeighbors) toNeighbors.push(edge.from);
            });
        }

         function onMouseEnter(args) {
           var diagram = document.getElementById("container").ej2_instances[0];
            if (args.actualObject && args.actualObject.id) {
                var hoverNode = args.actualObject;
                previousNode = hoverNode;
                if (hoverNode.id !== selectedNode) {
                    removeStepNumbers();
                    resetStyles();
                    var pathResult = findShortestPath(selectedNode, hoverNode.id);
                    var path = pathResult.path;
                    if (path.length > 0) {
                        var pathString = path.map(function (p) { return getNodeLabel(p); }).join(" → ");
                        // Update tooltip
                        hoverNode.tooltip.content = pathString;
                        diagram.showTooltip(hoverNode);
                        highlightNodes(path);
                        addStepNumbersToConnectors(path);
                        highlightPath(path);
                    }
                    else {
                        hoverNode.tooltip.content = 'No path found';
                        diagram.showTooltip(hoverNode);
                        // Show error state
                        hoverNode.style.fill = nodeErrorFill;
                        hoverNode.style.strokeColor = nodeErrorStroke;
                        if (!highlightedNodes.some(function (node) { return node.id === hoverNode.id; })) {
                            highlightedNodes.push(hoverNode);
                        }
                        var rootNode = diagram.getObject(selectedNode);
                        if (rootNode) {
                            rootNode.style.fill = nodeErrorFill;
                            rootNode.style.strokeColor = nodeErrorStroke;
                        }
                    }
                    diagram.dataBind();
                }
            }
        }
             
       function onGraphTypeChanged(args) {
               var diagram = document.getElementById("container").ej2_instances[0];
            isDirectedGraph = args.checked;
            diagram.connectors.forEach(function (connector) {
                // Update stroke style & decorator
                if (isDirectedGraph) {
                    connector.targetDecorator.shape = 'Arrow';
                    connector.style.strokeWidth = 2;
                    connector.style.strokeDashArray = '5,5';
                    connector.style.strokeColor = connectorDefaultStroke;
                }
                else {
                    connector.targetDecorator.shape = 'None';
                    connector.style.strokeColor = connectorDefaultStroke;
                    connector.style.strokeDashArray = '';
                    connector.style.strokeWidth = 2;
                    // Stop animation for undirected graph
                    removeConnectorDash(connector.id + '_path');
                }
            });
            diagram.dataBind();
        }

        function onMouseLeave(args) {
            if (previousNode) {
                   var diagram = document.getElementById("container").ej2_instances[0];
                diagram.hideTooltip(previousNode);
                var selectedNodeObj = diagram.getObject(selectedNode);
                if (selectedNodeObj) {
                    selectedNodeObj.style.strokeColor = nodeHighlightStroke;
                    selectedNodeObj.style.fill = nodeHighlightFill;
                    selectedNodeObj.style.strokeWidth = 4;
                }
                resetStyles();
                removeStepNumbers();
                diagram.dataBind();
            }
        }
        function onNodeClicked(args) {
               var diagram = document.getElementById("container").ej2_instances[0];
            if (args.element && args.element.id) {
                var clickedNode = args.element;
                previousSelectedNodeUpdated();
                selectedNode = clickedNode.id;
                clickedNode.style.strokeColor = nodeHighlightStroke;
                clickedNode.style.strokeWidth = 3;
                resetStyles();
                removeStepNumbers();
                diagram.dataBind();
            }
        }
        function previousSelectedNodeUpdated() {
              var diagram = document.getElementById("container").ej2_instances[0];
            var previousSelectedNode = diagram.nodes.find(function (node) { return node.id === selectedNode; });
            if (previousSelectedNode) {
                previousSelectedNode.style.strokeColor = nodeDefaultStroke;
                previousSelectedNode.style.strokeWidth = 2;
                previousSelectedNode.style.fill = nodeDefaultFill;
            }
        }
        function resetStyles() {
            // Reset highlighted connectors
            highlightedConnectors.forEach(function (connector) {
                connector.style.strokeColor = connectorDefaultStroke;
                connector.style.strokeWidth = 2;
                if (isDirectedGraph) {
                    connector.style.strokeDasharray = '5,5';
                    removeMovingDash(connector.id + '_path');
                }
            });
            highlightedConnectors = [];
            // Reset highlighted nodes
            highlightedNodes.forEach(function (node) {
                if (node.id !== selectedNode) {
                    node.style.fill = nodeDefaultFill;
                    node.style.strokeColor = nodeDefaultStroke;
                    node.style.strokeWidth = 2;
                }
            });
            highlightedNodes = [];
        }
        function getNeighbors(nodeId, directed) {
             var diagram = document.getElementById("container").ej2_instances[0];
            if (!directed) {
                // For undirected graph, return all connected nodes
                return graph.get(nodeId) || [];
            } else {
                // For directed graph, only return nodes that this node points to
                var neighbors = [];
                var outgoingConnectors = diagram.connectors.filter(function (connector) {
                    return connector.sourceID === nodeId;
                });
                outgoingConnectors.forEach(function (connector) {
                    if (connector.targetID) {
                        neighbors.push(connector.targetID);
                    }
                });
                return neighbors;
            }
        }
        function findShortestPath(start, end) {
                  if (graph.size === 0) {

            buildGraph();
        }

            if (!graph.has(start) || !graph.has(end)) {
                return { path: [], distance: 0 };
            }
            if (start === end) {
                return { path: [start], distance: 0 };
            }
            var queue = [start];
            var visited = new Set([start]);
            var previous = new Map();
            var distances = new Map();
            distances.set(start, 0);
            while (queue.length > 0) {
                var current = queue.shift();
                var neighbors = getNeighbors(current, isDirectedGraph);
                for (var i = 0; i < neighbors.length; i++) {
                    var neighbor = neighbors[i];
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        previous.set(neighbor, current);
                        distances.set(neighbor, distances.get(current) + 1);
                        queue.push(neighbor);
                        if (neighbor === end) {
                            break;
                        }
                    }
                }
                if (visited.has(end)) {
                    break;
                }
            }
            var path = [];
            if (visited.has(end)) {
                var currentNode = end;
                while (currentNode !== undefined) {
                    path.unshift(currentNode);
                    currentNode = previous.get(currentNode);
                }
            }
            return { path: path, distance: path.length > 0 ? path.length - 1 : 0 };
        }
        function highlightNodes(path) {
                    var diagram = document.getElementById("container").ej2_instances[0];
            path.forEach(function (nodeId) {
                var node = diagram.getObject(nodeId);
                if (node) {
                    node.style.fill = nodeHighlightFill;
                    node.style.strokeColor = nodeHighlightStroke;
                    node.style.strokeWidth = 3;
                    highlightedNodes.push(node);
                }
            });
        }
        function findConnector(sourceId, targetId) {
                  var diagram = document.getElementById("container").ej2_instances[0];
            return diagram.connectors.find(function (connector) {
                return (connector.sourceID === sourceId && connector.targetID === targetId) ||
                    (!isDirectedGraph && connector.sourceID === targetId && connector.targetID === sourceId);
            });
        }
        function highlightPath(path) {
                  var diagram = document.getElementById("container").ej2_instances[0];
            for (var i = 0; i < path.length - 1; i++) {
                var connector = findConnector(path[i], path[i + 1]);
                if (connector) {
                    connector.style.strokeColor = connectorHighlightStroke;
                    connector.style.strokeWidth = 4;
                    highlightedConnectors.push(connector);
                    if (isDirectedGraph) {
                        applyMovingDash(connector.id + '_path');
                    }
                }
            }
        }
        function addStepNumbersToConnectors(path) {
            for (var i = 0; i < path.length - 1; i++) {
                var connector = findConnector(path[i], path[i + 1]);
                if (connector && connector.annotations && connector.annotations.length > 0) {
                    connector.annotations[0].content = (i + 1).toString();
                    connector.annotations[0].style.fill = nodeHighlightStroke;
                }
            }
        }
        function removeStepNumbers() {
               var diagram = document.getElementById("container").ej2_instances[0];
            diagram.connectors.forEach(function (connector) {
                if (connector.annotations && connector.annotations.length > 0) {
                    connector.annotations[0].content = '';
                    connector.annotations[0].style.fill = 'transparent';
                }
            });
        }
        function getNodeLabel(nodeId) {
               var diagram = document.getElementById("container").ej2_instances[0];
            var node = diagram.nodes.find(function (n) { return n.id === nodeId; });
            return node && node.annotations && node.annotations[0] ? node.annotations[0].content : nodeId;
        }
        function applyMovingDash(pathId) {
            // Wait for the path to exist in the DOM
            var applyAnimationInterval = setInterval(function () {
                var element = document.getElementById(pathId);
                if (element) {
                    element.style.strokeDasharray = '8,4';
                    var offset = 0;
                    // Store the interval reference for this pathId
                    var interval = setInterval(function () {
                        offset -= 1;
                        element.setAttribute('stroke-dashoffset', offset.toString());
                    }, 50);
                    dashIntervals.set(pathId, interval);
                    clearInterval(applyAnimationInterval);
                }
            }, 10);
        }
        function removeMovingDash(pathId) {
            // Wait for the path to exist in the DOM for cleanup
            var removeAnimationInterval = setInterval(function () {
                var element = document.getElementById(pathId);
                if (element) {
                    // Clear dash animation interval if it exists
                    var interval = dashIntervals.get(pathId);
                    if (interval) {
                        clearInterval(interval);
                        dashIntervals.delete(pathId);
                    }
                    element.removeAttribute('stroke-dasharray');
                    element.removeAttribute('stroke-dashoffset');
                    clearInterval(removeAnimationInterval);
                    element.style.strokeDasharray = '5,5';
                }
            }, 10);
        }
        function removeConnectorDash(pathId) {
            var element = document.querySelector("[id='" + pathId + "']");
            if (element) {
                var interval = dashIntervals.get(pathId);
                if (interval) {
                    clearInterval(interval);
                    dashIntervals.delete(pathId);
                }
                element.style.strokeDasharray = '';
                element.removeAttribute('stroke-dasharray');
                element.removeAttribute('stroke-dashoffset');
            }
        }
        function Create() {
            var diagram = document.getElementById("container").ej2_instances[0];
            diagram.tool = ej.diagrams.DiagramTools.SingleSelect | ej.diagrams.DiagramTools.ZoomPan;
            diagram.fitToPage();
        }

    </script>

}
@section ActionDescription{
    <p>
        This sample demonstrates an interactive shortest path algorithm visualization using the Syncfusion<sup>®</sup> ASP.NET Core Diagram component, featuring a dynamic graph where users select source and destination nodes to view animated optimal paths.

    </p>
}
@section Meta{
                    <meta name="description" content="Visualize shortest paths using Dijkstra’s algorithm in Syncfusion ASP.NET Core Diagram. Interactive graph with animated connectors and dynamic node styling."/>
                }

@section Description{
    <p>
        Users can interactively find the shortest path by selecting a <b>"source"</b> node and hovering over a <b>"destination"</b>. The optimal path is dynamically highlighted using animated, dashed connectors and numerical labels. Tooltip instantly display the path sequence or show a <b>"No path found"</b> warning. A toggle allows seamless switching between directed and undirected graph modes.
    </p>
}
@section Title{
                    <title>ASP.NET Core Diagram Shortest Path Example - Syncfusion Demos </title> 
                }
@section Header{
    <h1 class='sb-sample-text'>Example of Shortest Path Visualization with Interactive Graph in ASP.NET Core Diagram Component</h1>
                }